---
title: "ADER18S - Analysis of Mouse Cell Atlas scRNA-seq using Seurat"
author: "Daniel Neves"
date: '17 Setembro, 2018'
output: 
  html_document:
    keep_md: yes
    number_sections: yes
    toc: yes
---



# Introduction

In [Han, Xiaoping, et al. "Mapping the mouse cell atlas by Microwell-seq." Cell 172.5 (2018)](https://doi.org/10.1016/j.cell.2018.02.001) a scRNA-seq dataset of approximately 400,000 cells isolated from all major mouse organs was generated by Microwell-seq. Expression matrices for all samples are available [here](https://figshare.com/s/865e694ad06d5857db4b). 

In the previous section of this course we processed the raw fastq files for a sample of cells from mouse lung in order to obtain an UMI count matrix for all mouse genes. Because we don't know how many cells are really in the sample, we constructed a matrix containing the most abundant 10,000 barcodes. 

In this tutorial we will perform the steps necessary to go from the raw expression matrix to a list of clusters representing transcriptionally distinct cell sub-populations and a list of marker genes associated with each identified cluster. 

# Libraries

First we load a few packages. `Seurat` is one of several packages designed for downstream analysis of scRNA-seq datasets. It implements functions to perform filtering, quality control, normalization, dimensional reduction, clustering and differential expression of scRNA-seq datasets. `gridExtra` is used to group multiple plots together in a grid.


```r
library(Seurat)
library(gridExtra)
```

# Loading and filtering the raw UMI count matrix

First we load the raw UMI matrix into the R environment. 


```r
mat.raw <- read.table(gzfile("matrices/lung1_full.dge.txt.gz"), header=TRUE)
rownames(mat.raw) <- mat.raw$GENE
mat.raw <- mat.raw[, -1]

dim(mat.raw)
```

```
## [1] 16815 10000
```

**Question**: How many genes and barcodes are quantified in this raw UMI matrix? 

<details><summary><b>Click Here to see the answer</b></summary> 16815 genes and 10000 barcodes. </details>

Next we plot the total number of UMI counts per barcode in the raw UMI matrix. 


```r
umi.per.barcode <- colSums(mat.raw)
x <- sort(umi.per.barcode, decreasing = TRUE)
plot(x, log="xy",type="l", xlab="Barcodes", ylab="UMI counts")
```

![](tutorial-seurat-mca_files/figure-html/unnamed-chunk-3-1.png)<!-- -->

**Question**: What can you conclude from the above representation? How many of the top barcodes would you keep for further analysis?

<details><summary><b>Click Here to see the answer</b></summary> 

There appears to be a drop in the total number of UMI counts after the first 1,000 barcodes. However, unlike what we saw in the 10x dataset, the separation between an empty GEM and a GEM containing a cell is less clear. This could be due to the presence of ambient RNA in the sample. 

In the original study the authors decided on a threshold of 500 UMI counts to select barcodes for further analysis. Thus we are left with 2709 cells for further analysis.


```r
plot(x, log="xy",type="l", xlab="Barcodes", ylab="UMI counts")
abline(h=500, lty="dashed")
```

![](tutorial-seurat-mca_files/figure-html/unnamed-chunk-4-1.png)<!-- -->

```r
(num.barcodes <- length(which(x >= 500)))
```

```
## [1] 2709
```

</details>

We remove from the matrix all barcodes below the selected total UMI threshold.


```r
mat.raw <- mat.raw[ , which(colSums(mat.raw) >= 500) ]

dim(mat.raw)
```

```
## [1] 16815  2709
```

To use the `Seurat` package, we first need to create a *Seurat object*. This is a complex data structure that will conveniently hold all relevant information during the analysis, such as the raw count data, the normalized expressions, reduced dimensions, cluster assignments, etc...

When creating the *Seurat object* we can specify certain filtering criteria that will immediately be applied to the matrix. Here we specify that we only want to consider genes expressed in at least 5 cells. Aproximately 3,500 genes are discarded from the matrix.


```r
sobj <- CreateSeuratObject(raw.data=mat.raw, min.cells = 5)

dim(sobj@data)
```

```
## [1] 13051  2709
```

Next we inspect the distributions of total counts per cell, and number of genes detected per cell. As expected, the higher the number of total counts in a cell, the higher the number of genes that we are able to detect.


```r
VlnPlot(sobj, features.plot = c("nUMI", "nGene"))
```

![](tutorial-seurat-mca_files/figure-html/unnamed-chunk-7-1.png)<!-- -->

```r
plot(sobj@meta.data$nUMI, sobj@meta.data$nGene, pch=20, cex=0.5)
```

![](tutorial-seurat-mca_files/figure-html/unnamed-chunk-7-2.png)<!-- -->

**Question**: Notice that the above plot seems to grow linearly. What does it suggest?

<details><summary><b>Click Here to see the answer</b></summary> 

This suggest that if the sample was sequenced deeper, we would be able to detect more genes.

</details>

Next we calculate the percentage of mitochondrial RNA in each cell and add this information as cell metadata. We then plot the distibutions of total UMI counts, number of detected genes and percent of mitochondrial RNA for all cells.


```r
mito.genes <- grep("^mt-", rownames(sobj@data), value = TRUE)
percent.mito <- Matrix::colSums(sobj@data[mito.genes, ]) / Matrix::colSums(sobj@data)
sobj <- AddMetaData(sobj, metadata = percent.mito, col.name = "percent.mito")

VlnPlot(sobj, features.plot = c("nUMI", "nGene", "percent.mito"))
```

![](tutorial-seurat-mca_files/figure-html/unnamed-chunk-8-1.png)<!-- -->

```r
plot(sobj@meta.data$nUMI, sobj@meta.data$percent.mito, pch=20, cex=0.5)
```

![](tutorial-seurat-mca_files/figure-html/unnamed-chunk-8-2.png)<!-- -->

A few cells display higher than 10% abundance of mitochondrial RNA. These cells also appear to have lower UMI counts than average.

**Question:** What is a possible explanation for a high percentage of mitochondrial RNA in a scRNA-seq cell?

<details><summary><b>Click Here to see the answer</b></summary> 

A high percentage of mitochondrial RNA ususally indicates a dead or burst cell, as cytoplasmic RNA is lost while mitochondrial RNA remains protected.

</details>

**Question:** Examine the distrubutions above. What cells, if any, would you remove from the analysis?

<details><summary><b>Click Here to see the answer</b></summary> 

A high percentage of mitochondrial RNA can indicate defective cells, so we should probably remove those. Also, barcodes with a much higher than average number of detected genes may indicate a multiplet (multiple cells in the same droplet), so we also remove barcodes with more than 1500 genes detected. 

</details>


```r
sobj <- FilterCells(sobj, subset.names = "nGene", high.thresholds = 1500)
sobj <- FilterCells(sobj, subset.names = "percent.mito", high.thresholds = 0.1)

dim(sobj@data)
```

```
## [1] 13051  2671
```




# Normalization

We need to normalize each cell for the total UMI counts for that cells. This normalization assumes that the total amount of RNA molecules in each cell is similar. We also log-transform the UMI counts and scale them to the median UMI counts across all cells.


```r
sobj <- NormalizeData(sobj, normalization.method = "LogNormalize", scale.factor = median(sobj@meta.data$nUMI))

sobj@data[1:10, 1:10]
```

```
## 10 x 10 sparse Matrix of class "dgCMatrix"
```

```
##    [[ suppressing 10 column names 'AACGCCGTCGGTCCTTTC', 'CCGCTAAACGCCTCGGGT', 'AGTCGTCCATCTGTATAC' ... ]]
```

```
##                                                                     
## 0610007P14Rik . .         .         . .       . . . .      .        
## 0610009B22Rik . .         0.2808266 . .       . . . .      .        
## 0610009L18Rik . .         .         . .       . . . .      0.2802496
## 0610009O20Rik . .         0.2808266 . .       . . . .      .        
## 0610010F05Rik . .         .         . .       . . . .      .        
## 0610011F06Rik . .         .         . 0.33184 . . . 0.5146 0.2802496
## 0610012G03Rik . .         .         . .       . . . .      .        
## 0610030E20Rik . .         .         . .       . . . .      .        
## 0610037L13Rik . 0.2616697 .         . .       . . . .      0.2802496
## 0610040B10Rik . .         .         . .       . . . .      .
```

# Finding highly variable genes

Housekeeping genes that are similarly expressed in all cell populations are not useful for the purpose of identifying these populations. Thus, it is often useful to select a subset of genes that display higher than average variability among cells to be used for dimensionality reduction and clustering of cells, as this will greatly speed-up the computations. 

The `FindVariableGenes` from the *Seurat* package does this by selecting genes that display a variance/mean ratio above a user-supplied threshold. Here we select genes that have a dispersion more than 0.5 standard deviations above the average dispersion of genes with a similar expression level (`y.cuttoff`). We can also set thresholds for minimum expression (`x.low.cutoff`) and maximum expression (`x.high.cutoff`).


```r
sobj <- FindVariableGenes(sobj, mean.function = ExpMean, dispersion.function = LogVMR,  
                          x.low.cutoff = 0.025, x.high.cutoff = 3, y.cutoff = 0.5)
```

```
## Warning in KernSmooth::bkde2D(x, bandwidth = bandwidth, gridsize = nbin, :
## Binning grid too coarse for current (small) bandwidth: consider increasing
## 'gridsize'
```

![](tutorial-seurat-mca_files/figure-html/vargenes-1.png)<!-- -->

```r
length(sobj@var.genes)
```

```
## [1] 935
```

We can check the expression of a few of these variable genes across all cells using the `VlnPlot` function. We plot the expression of the 6 variable genes with highest dispersion, and the 6 variable genes with highest mean.


```r
hvginfo <- sobj@hvg.info[ sobj@var.genes, ]
highest.dispersion <- head(rownames(hvginfo)[ order(-hvginfo$gene.dispersion) ])
highest.mean <- head(rownames(hvginfo)[ order(-hvginfo$gene.mean) ])

VlnPlot(sobj, features.plot = highest.dispersion, point.size.use=0.5)
```

![](tutorial-seurat-mca_files/figure-html/unnamed-chunk-11-1.png)<!-- -->

```r
VlnPlot(sobj, features.plot = highest.mean, point.size.use=0.5)
```

![](tutorial-seurat-mca_files/figure-html/unnamed-chunk-11-2.png)<!-- -->

# Dimensional reduction

In *Seurat*, principal component analysis is done on scaled expression data. The `ScaleData` function performs this step, and also allows to regress out common sources of technical variation, such as the total UMI counts per cell or the percentage of mitochondrial RNA.


```r
sobj <- ScaleData(object = sobj, vars.to.regress = c("nUMI", "percent.mito"))
```

```
## Regressing out: nUMI, percent.mito
```

```
## 
## Time Elapsed:  14.9373333454132 secs
```

```
## Scaling data matrix
```

Additionally, using the set of highly variable genes for dimensional reduction instead of the whole transcriptome helps to both speed-up the PCA computation and reduce the impact of low expressed (and noisy) genes.


```r
sobj <- RunPCA(object = sobj, pc.genes = sobj@var.genes, pcs.compute = 40, do.print=FALSE)

p1 <- PCAPlot(object = sobj, dim.1 = 1, dim.2 = 2, do.return=TRUE) + theme(legend.pos="none")
p2 <- PCAPlot(object = sobj, dim.1 = 2, dim.2 = 3, do.return=TRUE) + theme(legend.pos="none")
grid.arrange(p1, p2, ncol=2)
```

![](tutorial-seurat-mca_files/figure-html/unnamed-chunk-12-1.png)<!-- -->

The next question is how many of the top principal components (PCs) are we going to use for the purpose of clustering the cells. The first thing to look at is the PCA scree-plot, showing the proportion of variance explained by each component. We are looking for a "knee" in the plot, where additional PCs do not bring much more new information.

For this purpose, *Seurat* provides the function `PCElbowPlot`, that displays the standard-deviation of each PC.


```r
PCElbowPlot(sobj, num.pc = 40)
```

![](tutorial-seurat-mca_files/figure-html/unnamed-chunk-13-1.png)<!-- -->

We can also calculate the proportion of variance ourselves and plot it (the two representations are proportional to each other).


```r
eigs <- sobj@dr$pca@sdev**2
props <- eigs / sum(eigs)
plot(props, ylab="Proportion of variance", xlab="Principal Component")
```

![](tutorial-seurat-mca_files/figure-html/unnamed-chunk-14-1.png)<!-- -->

**Question**: Based on the above plots, how many principal components would you consider for further analysis.

<details><summary>Click Here to see the answer</summary>
There is a drop in the percentage of variance explained after PC15 and the plot seems to reach saturation after approximately 20 PCs. Thus, 15 to 20 PCs seem to be adequate for this dataset.
</details>


```r
PCHeatmap(sobj, pc.use = 1:15, cells.use = 500, do.balanced = TRUE, label.columns = FALSE)
```

![](tutorial-seurat-mca_files/figure-html/unnamed-chunk-15-1.png)<!-- -->


```r
VizPCA(sobj, pcs.use = 1:15, do.balanced = TRUE)
```

![](tutorial-seurat-mca_files/figure-html/unnamed-chunk-16-1.png)<!-- -->


```r
sobj <- JackStraw(sobj, num.pc = 40, num.replicate = 50, do.par=TRUE, display.progress = FALSE)
```

```
## Warning in JackStraw(sobj, num.pc = 40, num.replicate = 50, do.par =
## TRUE, : do.par set to TRUE but num.cores set to 1. Setting num.cores to 6.
```

```r
sobj <- JackStrawPlot(sobj, PCs = 1:40)
```

```
## Warning: Removed 28512 rows containing missing values (geom_point).
```

![](tutorial-seurat-mca_files/figure-html/unnamed-chunk-17-1.png)<!-- -->

```r
plot(1:40, -log10(sobj@dr$pca@jackstraw@overall.p.values[,2]))
abline(h=-log10(0.05))
```

![](tutorial-seurat-mca_files/figure-html/unnamed-chunk-17-2.png)<!-- -->



# Clustering

Because of the high dimensionality of scRNA-seq datasets, clustering algorithms face a number of challenges, such as high computation times and memory requirements. To alieviate these problems, one solution is to perform the clustering using the cells PCA scores instead of the full expression matrix. Here each principal component represents a ...

`Seurat` uses a graph based clustering algorithm (SNN). The `resolution` parameter influences the granularity of the clusters, with higher values producing more and smaller clusters.


```r
sobj <- FindClusters(sobj, reduction.type = "pca", dims.use = 1:15, 
    resolution = 1.2, print.output = 0, save.SNN = FALSE)

p1 <- PCAPlot(sobj, dim.1 = 1, dim.2 = 2, do.return=TRUE)
p2 <- PCAPlot(sobj, dim.1 = 2, dim.2 = 3, do.return=TRUE)
grid.arrange(p1, p2, ncol=2)
```

![](tutorial-seurat-mca_files/figure-html/clusters-1.png)<!-- -->


```r
mdf <- reshape2::melt(sobj@dr$pca@cell.embeddings[, 1:12], varnames=c("Barcode", "PC"))
mdf$Cluster <- sobj@ident[ match(mdf$Barcode, names(sobj@ident)) ]

ggplot(mdf, aes(x=value, col=mdf$Cluster)) + geom_density() + facet_wrap(~PC, nrow = 4)
```

![](tutorial-seurat-mca_files/figure-html/unnamed-chunk-18-1.png)<!-- -->



```r
#saveRDS(sobj@ident, file="seurat_clusters.Rds")
```


# Visualizing clusters with a t-SNE plot

t-distributed stochastic neighbor embedding is a nonlinear dimensionality reduction often used in scRNA-seq analyses to visualize cell subpolulations. It is used to embed high dimensional scRNA-seq expressions in a 2D or 3D plot. Its main advantage compared to PCA is its ability to detect structures in the data that cannot be found by simple rotations (see [t-SNE: What the hell is it?](https://constantamateur.github.io/2018-01-02-tSNE/)).

Although useful to visualize single cell data, care should be taken when interpreting its results:

- t-SNE is an iterative stochastic algorithm. This means that it will produce different results each time it is run. Also, care should be taken that the algorithm actually converges.
- Because t-SNE *does not preserve distances*, one should not over-interpret the higher order structures of the plot. i.e. just because two clusters appear close toghether on the plot, does not mean they are similar. 
- The t-SNE algorithm is highly sensitive to the choice of its *perplexity* parameter. This parameter determines what the algorithm considers to be neighboring points. i.e. the number of neighbors of each point is roughly equal to the specified perplexity.

Read more about t-SNE:

- [t-distributed stochastic neighbor embedding (Wikipedia)](https://en.wikipedia.org/wiki/T-distributed_stochastic_neighbor_embedding)
- [How to Use t-SNE Effectively](https://distill.pub/2016/misread-tsne/)

For scRNA-seq datasets, a `perplexity` value in the range of  20 to 50 usually produces good results.


```r
sobj <- RunTSNE(sobj, dims.use = 1:15, do.fast = TRUE)
TSNEPlot(sobj, do.label = TRUE)
```

![](tutorial-seurat-mca_files/figure-html/tsne-1.png)<!-- -->

Other clustering methods.


```r
# library(dynamicTreeCut)
# 
# dists <- dist(sobj@data)
# 
# cl2 <- hclust()
# 
# 
# sobj <- RunTSNE(sobj, dims.use = 1:15, do.fast = TRUE)
# TSNEPlot(sobj, do.label = TRUE)
```

# Finding marker genes

Seurat implements several methods for the discovery of cluster marker genes (differential expression). By default it uses two sample Wilcoxon tests, which for large datasets scRNA-seq with many cells has been shown to perform well. To speed up the computation, we will not test all genes, but only those that are destected in at least 25% of the cells in either population (the tested cluster or the combination of all other clusters) and have at least 0.25 log fold-change difference between the two populations.


```r
markers <- FindAllMarkers(object = sobj, only.pos = TRUE, min.pct = 0.25, thresh.use = 0.25)
markers <- markers[ markers$p_val_adj < 0.01, ]

write.table(markers, file="lung1_markers.txt")
```

The above command will return a table containing all identied markers (differentially expressed genes) for each cluster. For example, the *Sftpc* gene is identified as a marker gene for cluster 0. It is expressed in 100% of the cells of all clusters, but is 2-fold up-regulated in cells belonging to cluster 0.


```r
head(markers)
```

```
##                p_val avg_logFC pct.1 pct.2     p_val_adj cluster   gene
## Sftpc  1.055082e-157 0.9742411 1.000 1.000 1.376988e-153       0  Sftpc
## Sftpa1 1.984045e-152 1.1020114 0.996 0.846 2.589377e-148       0 Sftpa1
## Sftpd  3.654520e-132 0.8664690 0.984 0.579 4.769514e-128       0  Sftpd
## Cbr2   9.300043e-128 0.9219564 0.994 0.746 1.213749e-123       0   Cbr2
## Sftpb  9.081302e-127 0.9474188 0.992 0.731 1.185201e-122       0  Sftpb
## Wfdc2  2.958337e-119 0.7048043 0.972 0.503 3.860925e-115       0  Wfdc2
```

Seurat provides several functions to visualize the expression of these genes. 


```r
markers.0 <- markers[ which(markers$cluster == 0), ]
FeaturePlot(sobj, features.plot = head(rownames(markers.0)), cols.use = c("grey", "blue"), reduction.use = "tsne")
```

![](tutorial-seurat-mca_files/figure-html/unnamed-chunk-23-1.png)<!-- -->

```r
VlnPlot(sobj, features.plot = head(rownames(markers.0)), point.size.use=0.5)
```

![](tutorial-seurat-mca_files/figure-html/unnamed-chunk-23-2.png)<!-- -->

**Exercise**: Modify the commands above to plot the top markers of cluster 8.

<details><summary>Click Here to see the solution</summary>


```r
markers.8 <- markers[ which(markers$cluster == 8), ]
FeaturePlot(sobj, features.plot = head(rownames(markers.8)), cols.use = c("grey", "blue"), reduction.use = "tsne")
```

![](tutorial-seurat-mca_files/figure-html/unnamed-chunk-24-1.png)<!-- -->

```r
VlnPlot(sobj, features.plot = head(rownames(markers.8)), point.size.use=0.5)
```

![](tutorial-seurat-mca_files/figure-html/unnamed-chunk-24-2.png)<!-- -->

</details>

We can also visualize the top markers for all clusters as a single heatmap. 


```r
top.markers <- do.call(rbind, lapply(split(markers, markers$cluster), head))
DoHeatmap(sobj, genes.use = top.markers$gene, slim.col.label = TRUE, remove.key = TRUE)
```

![](tutorial-seurat-mca_files/figure-html/unnamed-chunk-25-1.png)<!-- -->

**Question**: Based on the t-SNE visualization, and expression of marker genes represented in the above plots, do you think any of the clusters should be combined? If yes, which ones?

<details><summary>Click Here to see the answer</summary>
It is clear from the expression heatmap that clusters 0, 1, 2 and possibly 13 represent the same population of cells. Clusters 8 and 9 also appear to be very similar, although they are clearly separated on the t-SNE. 
</details>

We can check for differences between two specific clusters. Below we check if there any genes that distiguish clusters 0 and 1. It appears that these clusters are distiguished only by a small difference in the expression of 5 mitochondrion encoded genes. 


```r
markers.0.1 <- FindMarkers(sobj, ident.1 = 0, ident.2 = 1, min.pct=0.25)
markers.0.1 <- markers.0.1[ markers.0.1$p_val_adj < 0.01, ]

markers.0.1
```

```
##                p_val  avg_logFC pct.1 pct.2    p_val_adj
## mt-Nd4  9.961751e-51 -0.3923274 0.990 1.000 1.300108e-46
## mt-Nd1  6.986866e-48 -0.3749705 0.986 1.000 9.118558e-44
## mt-Nd2  1.739375e-40 -0.3688947 0.978 1.000 2.270059e-36
## mt-Cytb 4.614817e-39 -0.3081076 0.994 1.000 6.022798e-35
## mt-Nd5  2.271263e-18 -0.3191316 0.811 0.893 2.964226e-14
```

**Exercise**: Modify the commands above to check for diferences between clusters 0 and 2, 0 and 13 and 8 and 9.

<details><summary>Click Here to see the solution</summary>


```r
markers.0.2 <- FindMarkers(sobj, ident.1 = 0, ident.2 = 2, min.pct=0.25)
(markers.0.2 <- markers.0.2[ markers.0.2$p_val_adj < 0.01, ])
```

```
##              p_val avg_logFC pct.1 pct.2    p_val_adj
## Sftpc 1.602005e-63 0.3518711     1     1 2.090776e-59
```

```r
markers.0.13 <- FindMarkers(sobj, ident.1 = 0, ident.2 = 13, min.pct=0.25)
(markers.0.13 <- markers.0.13[ markers.0.13$p_val_adj < 0.01, ])
```

```
##                p_val  avg_logFC pct.1 pct.2    p_val_adj
## mt-Nd2  3.315311e-29 -0.8216176 0.978 1.000 4.326812e-25
## mt-Nd1  3.375789e-29 -0.7533235 0.986 1.000 4.405742e-25
## mt-Nd4  6.078753e-29 -0.7455023 0.990 1.000 7.933380e-25
## mt-Cytb 1.574442e-25 -0.6320817 0.994 1.000 2.054804e-21
## mt-Co1  1.183547e-14 -0.4943552 0.896 0.942 1.544647e-10
## Sftpa1  1.414640e-13  0.3821763 0.996 0.971 1.846246e-09
## mt-Nd5  2.567116e-12 -0.5864085 0.811 0.928 3.350343e-08
## Gm42418 1.057011e-07 -0.4347929 0.197 0.435 1.379505e-03
```

```r
markers.8.9 <- FindMarkers(sobj, ident.1 = 8, ident.2 = 9, min.pct=0.25)
(markers.8.9 <- markers.8.9[ markers.8.9$p_val_adj < 0.01, ])
```

```
##                 p_val  avg_logFC pct.1 pct.2    p_val_adj
## Dcn      1.332119e-30  1.5535752 0.991 0.474 1.738549e-26
## Serpinf1 1.117230e-26  1.0334890 0.791 0.123 1.458097e-22
## Clec3b   1.377908e-21  0.8205276 0.861 0.342 1.798308e-17
## Pi16     2.232171e-21  0.8471463 0.696 0.079 2.913206e-17
## Igfbp4   2.386887e-21  0.9931329 0.878 0.298 3.115126e-17
## Ly6a     2.563792e-20  0.9147230 0.739 0.167 3.346005e-16
## Cxcl14   1.140379e-18 -0.9942767 0.052 0.596 1.488308e-14
## Npnt     1.608033e-17 -0.6885091 0.043 0.553 2.098644e-13
## Col1a1   1.669303e-17  0.9657462 0.939 0.667 2.178607e-13
## Col3a1   1.606787e-16  1.0313486 0.983 0.754 2.097017e-12
## Col1a2   1.274876e-15  0.8754827 1.000 0.860 1.663840e-11
## Htra3    1.495799e-14  0.5296903 0.591 0.123 1.952167e-10
## Hspb1    3.216878e-14 -0.8153372 0.165 0.649 4.198348e-10
## Gsn      5.207615e-13  0.5928834 0.991 0.939 6.796458e-09
## Scara5   1.928997e-12  0.3085261 0.383 0.009 2.517535e-08
## Cygb     2.418410e-12  0.5693137 0.774 0.360 3.156267e-08
## Ctsl     2.441052e-12  0.5038861 0.930 0.640 3.185817e-08
## Col14a1  2.525322e-12  0.4170803 0.609 0.149 3.295797e-08
## Cd34     3.350560e-12  0.4839263 0.635 0.202 4.372816e-08
## Sparc    5.917541e-12  0.7102619 0.991 0.939 7.722983e-08
## Fbln1    7.389221e-12  0.4841551 0.748 0.333 9.643672e-08
## Dpt      9.780515e-12  0.5513043 0.800 0.395 1.276455e-07
## Limch1   2.000545e-11 -0.4371193 0.070 0.447 2.610911e-07
## Sept4    3.498856e-11 -0.5065655 0.078 0.456 4.566356e-07
## Meg3     4.330624e-11  0.5116606 0.513 0.114 5.651897e-07
## Rgs2     6.226054e-11 -0.7905175 0.052 0.404 8.125622e-07
## Pcolce   9.170627e-11  0.4962229 0.791 0.482 1.196859e-06
## Cxcl12   2.027299e-10  0.5512718 0.574 0.193 2.645828e-06
## Serpinh1 3.296941e-10  0.4849631 0.878 0.561 4.302837e-06
## Hsd11b1  3.341205e-10 -0.5959751 0.122 0.491 4.360607e-06
## Cd248    2.755667e-09  0.2927748 0.339 0.035 3.596421e-05
## Itga8    3.033353e-09 -0.2989370 0.009 0.289 3.958829e-05
## Entpd2   3.360442e-09  0.2720370 0.330 0.026 4.385713e-05
## Serping1 3.537203e-09  0.4842611 0.939 0.728 4.616404e-05
## Aldh1a1  4.483571e-09 -0.4164178 0.087 0.404 5.851508e-05
## Gpx3     6.618207e-09 -0.8417447 0.478 0.711 8.637421e-05
## Aebp1    1.269796e-08  0.4270354 0.600 0.254 1.657211e-04
## Ccl11    1.449863e-08  0.2908968 0.270 0.009 1.892216e-04
## Ppp1r14a 2.239702e-08 -0.3673775 0.052 0.333 2.923035e-04
## Ly6c1    2.432292e-08  0.4603056 0.330 0.044 3.174384e-04
## Gyg      2.674024e-08 -0.2993991 0.043 0.325 3.489869e-04
## Tmem176a 2.899758e-08 -0.4449104 0.278 0.596 3.784474e-04
## Tmem176b 3.374194e-08 -0.4334090 0.383 0.684 4.403661e-04
## Sftpc    3.863057e-08 -0.5363391 1.000 1.000 5.041675e-04
## Sparcl1  3.865563e-08 -0.5543617 0.609 0.789 5.044946e-04
## Pdia3    4.073035e-08  0.3280157 0.617 0.246 5.315719e-04
## Thbs1    5.588092e-08 -0.6330568 0.096 0.395 7.293019e-04
## Olfml2b  7.174506e-08  0.2550455 0.374 0.070 9.363448e-04
## Csrp1    8.060399e-08 -0.4301988 0.304 0.570 1.051963e-03
## Htra1    8.414494e-08  0.2835665 0.496 0.158 1.098176e-03
## Tns1     2.637751e-07 -0.3725115 0.148 0.421 3.442529e-03
## Lum      2.738703e-07  0.3224421 0.383 0.088 3.574282e-03
## Mettl7a1 3.495808e-07 -0.4365506 0.157 0.447 4.562379e-03
## Mylk     4.864975e-07 -0.3892156 0.087 0.351 6.349278e-03
## Ces1d    7.087287e-07 -0.3132069 0.035 0.263 9.249618e-03
```


```r
FeaturePlot(sobj, features.plot = c("Dcn", "Cxcl14"), cols.use = c("grey", "blue"), reduction.use = "tsne")
```

![](tutorial-seurat-mca_files/figure-html/unnamed-chunk-28-1.png)<!-- -->

It appears that most differences between clusters 0, 1, 2 and 13 are due to mitochondrial RNA. Clusters 8 and 9 however display a larger amount of differentially expressed genes, and might represent different cell populations.

</details>

We will merge clusters 0, 1, 2 and 13 into a single cluster.



We will now compare our results to those from the pusblished study. To do so, we will import the annotated cell assignments and store them as metadata in the *Seurat* object. Then we plot our t-SNE projection highlighting the annotated cell assignments.


```r
annotation <- read.table("reference/MCA_CellAssignments.csv", header=TRUE, sep=",")

sobj@meta.data$Cell.name <- paste0("Lung_1.", rownames(sobj@meta.data))

sobj@meta.data$Annotation <- annotation$Annotation[ match(sobj@meta.data$Cell.name, annotation$Cell.name) ]
sobj@meta.data$Annotation <- gsub("\\(Lung\\)", "", sobj@meta.data$Annotation)

sobj@meta.data$AnnotationSimple <- gsub("_.*", "", sobj@meta.data$Annotation)
```



```r
TSNEPlot(sobj, group.by="Annotation", do.label=TRUE, do.return=TRUE) + theme(legend.position = "none") 
```

```
## Warning: Removed 1 rows containing missing values (geom_text).
```

![](tutorial-seurat-mca_files/figure-html/unnamed-chunk-31-1.png)<!-- -->

```r
TSNEPlot(sobj, group.by="AnnotationSimple", do.label=TRUE, do.return=TRUE) + theme(legend.position = "none") 
```

```
## Warning: Removed 1 rows containing missing values (geom_text).
```

![](tutorial-seurat-mca_files/figure-html/unnamed-chunk-31-2.png)<!-- -->


```r
FeaturePlot(sobj, features.plot = "nUMI", no.legend=FALSE)
```

![](tutorial-seurat-mca_files/figure-html/unnamed-chunk-32-1.png)<!-- -->

We can also reproduce figure 4D.


```r
genes <- c("Sftpc", "Vwf", "Dcn", "Cxcl14")
FeaturePlot(sobj, features.plot = genes, cols.use=c("grey", "red"), no.legend = FALSE)
```

![](tutorial-seurat-mca_files/figure-html/unnamed-chunk-33-1.png)<!-- -->






```r
# sobj.p10 <- RunTSNE(object = sobj, dims.use = 1:20, do.fast = TRUE, perplexity=5)
# plot.p10 <- TSNEPlot(object = sobj.p10, do.return=TRUE) + ggtitle("Perplexity 5")
# 
# sobj.p30 <- RunTSNE(object = sobj, dims.use = 1:20, do.fast = TRUE, perplexity=10)
# plot.p30 <- TSNEPlot(object = sobj.p30, do.return=TRUE) + ggtitle("Perplexity 10")
# 
# sobj.p50 <- RunTSNE(object = sobj, dims.use = 1:20, do.fast = TRUE, perplexity=30)
# plot.p50 <- TSNEPlot(object = sobj.p50, do.return=TRUE) + ggtitle("Perplexity 30")
# 
# sobj.p100 <- RunTSNE(object = sobj, dims.use = 1:20, do.fast = TRUE, perplexity=50)
# plot.p100 <- TSNEPlot(object = sobj.p100, do.return=TRUE) + ggtitle("Perplexity 50")
# 
# grid.arrange(plot.p10, plot.p30, plot.p50, plot.p100)
```





# Session Information


```r
sessionInfo()
```

```
## R version 3.4.4 (2018-03-15)
## Platform: x86_64-pc-linux-gnu (64-bit)
## Running under: Ubuntu 16.04.4 LTS
## 
## Matrix products: default
## BLAS: /usr/lib/libblas/libblas.so.3.6.0
## LAPACK: /usr/lib/lapack/liblapack.so.3.6.0
## 
## locale:
##  [1] LC_CTYPE=pt_PT.UTF-8       LC_NUMERIC=C              
##  [3] LC_TIME=pt_PT.UTF-8        LC_COLLATE=en_US.UTF-8    
##  [5] LC_MONETARY=pt_PT.UTF-8    LC_MESSAGES=en_US.UTF-8   
##  [7] LC_PAPER=pt_PT.UTF-8       LC_NAME=C                 
##  [9] LC_ADDRESS=C               LC_TELEPHONE=C            
## [11] LC_MEASUREMENT=pt_PT.UTF-8 LC_IDENTIFICATION=C       
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
## [1] bindrcpp_0.2.2 gridExtra_2.3  Seurat_2.3.3   Matrix_1.2-14 
## [5] cowplot_0.9.2  ggplot2_2.2.1 
## 
## loaded via a namespace (and not attached):
##   [1] tsne_0.1-3           segmented_0.5-3.0    nlme_3.1-137        
##   [4] bitops_1.0-6         bit64_0.9-7          RColorBrewer_1.1-2  
##   [7] rprojroot_1.3-2      prabclus_2.2-6       tools_3.4.4         
##  [10] backports_1.1.2      irlba_2.3.2          R6_2.2.2            
##  [13] rpart_4.1-13         KernSmooth_2.23-15   Hmisc_4.1-1         
##  [16] lazyeval_0.2.1       colorspace_1.3-2     trimcluster_0.1-2   
##  [19] nnet_7.3-12          tidyselect_0.2.4     diffusionMap_1.1-0  
##  [22] bit_1.1-12           compiler_3.4.4       htmlTable_1.11.1    
##  [25] hdf5r_1.0.0          labeling_0.3         diptest_0.75-7      
##  [28] caTools_1.17.1       scales_1.0.0         checkmate_1.8.5     
##  [31] lmtest_0.9-35        DEoptimR_1.0-8       mvtnorm_1.0-6       
##  [34] robustbase_0.92-8    ggridges_0.5.0       pbapply_1.3-4       
##  [37] dtw_1.18-1           proxy_0.4-21         stringr_1.3.1       
##  [40] digest_0.6.16        mixtools_1.1.0       foreign_0.8-70      
##  [43] rmarkdown_1.9        R.utils_2.6.0        base64enc_0.1-3     
##  [46] pkgconfig_2.0.2      htmltools_0.3.6      htmlwidgets_1.2     
##  [49] rlang_0.2.2          rstudioapi_0.7       bindr_0.1.1         
##  [52] jsonlite_1.5         zoo_1.8-1            ica_1.0-1           
##  [55] mclust_5.4           gtools_3.5.0         acepack_1.4.1       
##  [58] dplyr_0.7.6          R.oo_1.21.0          magrittr_1.5        
##  [61] modeltools_0.2-21    Formula_1.2-2        lars_1.2            
##  [64] Rcpp_0.12.18         munsell_0.5.0        reticulate_1.5      
##  [67] ape_5.1              R.methodsS3_1.7.1    scatterplot3d_0.3-40
##  [70] stringi_1.2.4        yaml_2.2.0           MASS_7.3-50         
##  [73] flexmix_2.3-13       gplots_3.0.1         Rtsne_0.13          
##  [76] plyr_1.8.4           grid_3.4.4           parallel_3.4.4      
##  [79] gdata_2.18.0         crayon_1.3.4         doSNOW_1.0.16       
##  [82] lattice_0.20-35      splines_3.4.4        SDMTools_1.1-221    
##  [85] knitr_1.20           pillar_1.3.0         igraph_1.2.1        
##  [88] fpc_2.1-10           reshape2_1.4.3       codetools_0.2-15    
##  [91] stats4_3.4.4         glue_1.3.0           evaluate_0.10.1     
##  [94] metap_0.9            latticeExtra_0.6-28  data.table_1.11.4   
##  [97] png_0.1-7            foreach_1.4.4        tidyr_0.8.1         
## [100] gtable_0.2.0         RANN_2.5.1           purrr_0.2.5         
## [103] kernlab_0.9-25       assertthat_0.2.0     class_7.3-14        
## [106] survival_2.42-3      tibble_1.4.2         snow_0.4-2          
## [109] iterators_1.0.9      cluster_2.0.6        fitdistrplus_1.0-9  
## [112] ROCR_1.0-7
```

# References

- https://satijalab.org/seurat/pbmc3k_tutorial.html
- https://f1000research.com/articles/5-2122/v1

